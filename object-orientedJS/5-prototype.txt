//一种添加属性和方法的方式
function Gadget(name,color){
    this.name = name;
    this.color = color;
    this.whatAreYou = function(){
        return 'I am a '+this.color+''+this.name;
    }
}

//另一种方式：通过构造器函数的prototype属性
Gadget.prototype.price = 100;
Gadget.prototype.rating = 100;
Gadget.prototype.getInfo = function() {
    return 'Rating: ' + this.rating +',price: '+this.paice;
};

//也可以另外定义一个对象，将原型覆盖
Gadget.prototype = {
    price:100,
    rating:3,
    getInfo:function(){
        return 'Rating: '+ this.rating + ',price: '+this.price;
    }
}

//用构造器Gadget()新建一个newtoy对象。
>>> var newtoy = new Gadget('webcam','black');
undefined
>>> newtoy.name
"webcam"
>>> newtoy.whatAreYou();
"I am a blackwebcam"
>>> newtoy.price
100
>>> newtoy.rating
3
>>> newtoy.getInfo();
"Rating: 3,price: 100"

向原型中添加一个新方法：
Gadget.prototype.get = function(what){ return this[what];};

虽然newtoy在get()定义之前就创建了，但依然可以在该对象中访问新增的方法。
>>> newtoy.get('price');
100
>>> newtoy.get('color');
"black"

//如果在一个对象自身属性中没有找到指定的属性，就可以去（如果有的话）原型链中查找相关
的属性。如果对象的自身属性与原型属性同名，那么对象自身属性的优先级高于原型属性。
function Gadget(name){
    this.name = name;    
}
Gadget.prototype.name = 'foo';    //Gadget的name属性 为“foo”
"foo"                       
>>> var toy = new Gadget('camera');
undefined
>>> toy.name;     //toy的name属性
"camera"
>>> delete toy.name;  //删除toy的name属性
true
>>> toy.name     //此时name的属性值为“foo”
"foo"
>>> toy.name = 'camera';    //重建toy的name属性
"camera"
>>> toy.name;
"camera"


@枚举属性
var a = [1,2,3];
for (var i in a){
    console.log(a[i]);
}
1
2
3


var o = {p1:1,p2:2};
for (var i in o) {
    console.log(i + '=' + o[i]);
}
p1=1
p2=2



function Gadget(name,color) {
    this.name = name;
    this.color = color;
    this.someMethod = function(){return 1;}
}
Gadget.prototype.price = 100;
Gadget.prototype.rating = 3;

//新建一个对象
>>> var newtoy = new Gadget('webcam','black');
//for(var prop in newtoy) {
//    console.log(prop + ' = ' + newtoy[prop]);
//}
>>> for(var prop in newtoy) {      console.log(prop + ' = ' + newtoy[prop]);  }

name = webcam
color = black
someMethod = function (){return 1;}
price = 100
rating = 3


>>> newtoy.hasOwnProperty('name')  //name是自身属性
true
>>> newtoy.hasOwnProperty('price') //price是原型属性
false

//只显示对象的自身属性
for (var prop in newtoy) {
    if (newtoy.hasOwnProperty(prop)) {
        console.log(prop + '=' + newtoy[prop]);
    }
}
name=webcam
color=black
someMethod=function (){return 1;}

//propertyIsEnumerable()会对所有的非内建对象属性返回true。
>>> newtoy.propertyIsEnumerable('name');
true
>>> newtoy.propertyIsEnumerable('constructor')  //内建属性和方法大部分是不可枚举的
false
>>> newtoy.propertyIsEnumerable('price')  //任何来自原型链中的二属性也是不可枚举的
false
>>> newtoy.constructor.prototype.propertyIsEnumerable('price')  //??????
true

@isPrototype    判断当前对象是否是另一个对象的原型。
var monkey = {
    hair: true,
    feeds: 'banabas',
    brethes: 'air'
};

function Human(name) {
    this.name = name;
}
Human.prototype = monkey;

>>> var george = new Human('George');
undefined
>>> monkey.isPrototypeOf(george);
true


@_proto_链接 （只能在学习或调试的环境下使用，实践有风险）

var monkey = {
    feeds: 'bananas',
    breathes: 'air'
};
function Human() {}
Human.prototype = monkey;

>>> var developer = new Human();
>>> developer.feeds = 'pizza';
"pizza"
>>> developer.hacks = 'JavaScript';
"JavaScript"

>>> developer.breathes;   //从monkey中找
"air"
  
>>> developer.constructor = 'junk'    //将developer的constructor赋值为“junk”
"junk"
>>> typeof developer.constructor.prototype
"undefined"
>>> developer.breathes   //但此时依然可以调用breathes
"air"
>>> developer.__proto__
Object { feeds="bananas", breathes="air"}

>>> monkey.test = 1;  //改变monkey
1
>>> developer.test    //developet的也跟着改变
1
>>> typeof developer.__proto__      //__proto__是某个实体对象的属性，prototype则是属于构造器函数的属性。
"object"
>>> typeof developer.__proto__.prototype
"undefined"

@扩展内建对象
Array.prototype.inArray = function(needle) {
    for (var i =0,len = this.length; i<len; i++){
    if (this[i] === needle){
        return true;
      }
    }
    return false;
}

>>> var a = ['red','green','blue'];
undefined
>>> a.inArray('red');
true
>>> a.inArray('yellow');
false

//添加一个反转字符串的功能
String.prototype.reverse = function() {
    return Array.prototype.reverse.apply(this.split('')).join('');
}
>>> "Stoyan".reverse();
"nayotS"








