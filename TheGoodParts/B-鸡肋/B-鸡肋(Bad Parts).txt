B-鸡肋(Bad Parts)

B.1  ==
始终使用=== 和 ！===，不要使用== 和 ！==。
“==”“！==”只有在两个运算数类型一致时才会做出正确地判断，但如果两个运算数是不同的类型是，它们试图去前置转换其值的类型。
>>> ' ' == '0'
false
>>> 0 == ' '
true
>>> 0 == '0'
true
>>> false == 'false'
false
>>> false == '0'
true
>>> false == undefined
false
>>> false == null
false
>>> null == undefined
true
>>> '\t\r\n' == 0
true

B.2 with语句
JavaScript提供了一个with语句，本意是想用来快捷地访问对象的属性。不幸的是，它的结果可能有事是不可预料的，所以应该避免使用它。

B.3 eval
eval函数传递一个字符串给JavaScript编译器，并且执行其结果。使用eval形式的代码会更加难以阅读。会使性能显著降低，还键入了应用的安全性。

B.4 continue语句
continue语句跳刀循环的顶部。（作者）发现一段代码通过移除continue语句后，性能都会得到改善。

B.5  switch贯穿
除非明确的中断流程，否则每次条件判断后多贯穿到下一个case条件。

B.6 缺少块的语句
If、while、do或for语句可以接受一个括在花括号中的代码块，也可以接受单行语句。单行语句的形式是另一种带刺的玫瑰。它带来的好处是可以节约两个字节，但这是不是个好处值得商榷。它模糊了程序的结构，使得在随后的操作代码种可能很容易插入错误。

B.7 ++--
递增和递减运算符使得程序员可以用非常简洁的风格去编码。大多数的缓冲区溢出错误所造成的安全漏洞，都是由于像这样编码而导致的。

B.8 位运算符
JavaScript有着与Java相同的一套位运算符。但JavaScript没有整数类型，它只有双精度的浮点数，因此，位操作将它们的数字运算数先转化成整数，接着执行运算，然后再转化回去。在大多数语言中，这些位运算符接近于硬件处理而非常快。在JavaScript中，它们非但不是硬件处理，而且非常慢。JavaScript很少被用来执行位操作。

B.9 function语句对比函数表达式
JavaScript既有functionn语句，同时也有函数表达式，这是邻人困惑的，因为它们看起来好像就是相同的。一个function语句就是其值为一个函数的var语句速记形式。
语句 function foo() {} 意思相当于：var foo = function foo() {};

B.10 类型的包装对象     ???
JavaScript有一套类型的包装对象。例如：
	new Boolean(false)
会返回一个对象。该对象有一个valueOf方法会返回被包装的值。这其实完全没有必要，并且有时还令人困惑，不要使用new Boolean、new Number或new String。此外也请避免使用new Object 和new Array。可以用{}和[]来代替。

B.11  new
JavaScript的new运算符创建一个继承于其运算数的原型的新对象，然后调用该运算数，把新创建的对象绑定给this。这给运算数（它应该是一个构造器函数）一个机会在返回给请求者前去定义新创建的对象。
如果忘记了使用此new运算符，所得到的的就是一个普通的函数调用，并且this被绑定到全局变量，而不是新创建的对象。那意味着当你的函数去初始化新成员元素师它将会污染全局变量。

B.12 void
在很多语言中，void是一种类型，表示没有值，而在JavaScript里，void是一个运算符，它接受一个运算数并返回undefined。这没什么用，应该避免使用。
