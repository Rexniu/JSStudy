第7章 正则表达式(Regular Expressions)
   JavaScript的许多特性都借鉴自其它语言。语法借鉴自Java，函数借鉴自Scheme，原型借鉴自Self，而JavaScript的正则表达式则借鉴自Perl。
   JavaScript中，正则表达式必须写在一行中，正则表达式中的空白是至关重要的。

var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

   ^ 表示这个字符串的开始，它是一个标记，用来防止exec跳过不像URL(non-URL-like)的前缀：

   (?:([A-Za-z]+):)?
这个因子匹配一个协议名，但仅当他之后跟随一个:的时候才匹配。(?:...)表示一个非捕获型分组。后缀?表示这个分组是可选的。（...）表示一个捕获型分组，一个捕获型分组都将被指定一个编号。第一个捕获型分组的编号是1，所以改风阻所匹配的文本拷贝将出现在result[2]中。   [...]表示一个字符类，这个字符类A-Za-a包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。后缀+表示这个字符类将被匹配1次或多次。这个组后面跟着字符：，它将按字面进行匹配:
   (\/{0,3})
下一个因子是捕获型分组2，\/表示一个应该被匹配的/（斜杠）。它用\（反斜杠）来进行转义，这样它就不会被错误的解释为这个正则表达式的结束符。后缀{0,3}表示/将被匹配0次，或者1到3次之间：
   ([0-9.\-A-Za-z]+)
下一个因子是捕获型分组3，它将匹配一个主机名，有1个或多个数字而组成的序列。\d表示一个数字字符。1个或多个数字组成的数字串将被捕获型分组4捕获：
   (?::(\d+))?
下一个可选的因子将匹配端口号，它是由一个前置：加上1个或多个数字而组成的序列。\d表示一个数字字符。1个或多个数字组成的数字串将被捕获型分组4捕获：
   (?:\/([^?#]*))?
我们有另一个可选的分组，该分组以一个/开始。之后的字符类{^?#}以一个^开始，它表示这个类包含除？和#之外的所有字符。*表示这个字符类将被匹配0次或多次。
   (?:\?([^?#]*))?
一个以一个?开始的可选分组，它包含捕获型分组6，这个分组包含0个或多个非#字符：
   (?:#(.*))?
最后一个可选分组也是以#开始的，.将匹配除行结束符以外的所有字符：
   $
$表示这个字符串的结束，它让我们确信这个URL的尾部没有其他更多的内容。

@一个匹配数字的正则表达式

var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
var test = function(num) {
    document.writeln(parse_number.test(num));
};
test('1');     //false
>>> test('numbers');   //false
>>> test('98.6');    //true
>>> test('132.21.86.100');  /false
>>> test('123.45e-67');   //true

  /^  $/i
用^和$来框定这个正则表达式，它将导致文本中的所有字符都要针对这个正则表达式进行匹如果我们省略了这些表示，那么只要一个字符串包含一个数字，这个正则表达式就会告诉我们。但有了这些标识，只有当一个字符串的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^，它将匹配一个数字开头的字符串，如果我们仅包含$，则匹配一个数字结尾的字符串。
i标识规定当匹配字母是可以忽略大小写，在我们模式中唯一可能出现的字母是e。我们希望e也能匹配E。我们可以将e因子写成[Ee]或(?:E|e)，但不必这么麻烦，因为我们使用了标识符:i:
   -?
减号后面的？后缀表示这个减号是可选的：
   /d+
\d的含义和[0-9]一样。它匹配一个数字。后缀+规定它可以匹配1个或多个数字：
   (?:\.\d*)
（？:....）？表示一个可选的非捕获型分组。通常用非捕获型分组来替代少量不优美的捕获型分组是很好的方法，因为捕获会有性能上的损失。这个分组将匹配后面跟随0个或多个数字的小数点：
   (?:e[+\-]?\d+)?
这是另外一个可选的非捕获型分组，它将匹配一个e(或E)、一个可选的正负号及一个或多个数字。

@结构
   创建RegExp对象，两个方法，优先使用正则表达式字面量。
var my_regexp = /"(?:\\.|[^\\\"])"/g;
   正则表达式字面量被包围在一对斜杠中。
   有3个标志能在RegExp中设置，g、i、m；这些标志被直接添加在RegExp字面量的末尾。
G  全局的（匹配多次；准确含义随方法而变）
I  大小写不敏感（忽略字符大小写）
M  多行（^和$能匹配行结束符）
   创建一个正则表达式的另一个方法是使用RegExp构造器。这个构造器接受一个字符串，并把它编译为一个RegExp对象。（通常需要双写反斜杠及对双引号进行转义）

var my_regexp = new RegExp("\"(?:\\.|[^\\\\\\\"]),'g');

@元素
   一个正则表达式选择包含1个或多个正则表达式序列。这些序列被|字符分隔。 
   “into”.match(/in|int/)将在into中匹配in，但它不会匹配int，因为in已经被匹配成功了。
  一个正则表达式序列包含1个或多个正则表达式因子。每个因子能选择是否能跟随一个量词，这个量词决定着这个因子备孕训出现的次数。如果没有指定这个量词，那么该因子将被匹配一次。
  一个正则表达式因子可以是一个字符、一个有圆括号包围的组、一个字符类，或者是一个转义序列。
  \ / [ ] () {} ? + * | . ^ $
如果上面的字符按字面去匹配，那么必须要用一个\前缀来进行转义。

   反斜杠字符在正则表达式因子中与其在字符串中一样君表示转义，但是在正则表达式因子中，它稍有一点不同。
   像在字符创中一样，\f是换页符，\n是换行符，\r是回车符，\t是制表(tab)符，并且\u允许指定一个Unicode字符来表示一个十六进制的常量，但在正则中，\b不是退格符（backspace）
   \d等同于[0-9]。它会匹配一个数字，\D则表示与其相反的：[^0-9]
   \s等同于[\f\n\r\u000B\u0020\u00A0\u2028\u2029]，这是Unicode空白（whitespace）符的一个不完全子集。\S则表示与其相反的：[……\f\n\r\u000B\u0020\u00A0\u2028\u2029]
    \w等同于[0-9A-z_a-z]。\W表示[^0-9A-z_a-z]
    \b被指定为一个子边界标志，这将方便于对文本的子边界进行匹配。
    \l是指向分组l所捕获到的文本的一个引用，所以她能被再次匹配。
@正则表达式分组：4种：捕获型，非捕获型，向前正向匹配，向前负向匹配。
@正则表达式类是一种指定一组字符的便利方式，例如，如果相匹配一个元音字母，我们可以写作(?:a|e|i|o|u)，但它可以被更方便的写成一个类[aeiou].

@正则表达式因子量词
   包围在一对花括号中的一个数字表示这个因子应该被匹配的次数。所以/www/匹配的和/w{3}/一样，{3，6}将匹配3、4、5、或6次。{3，}将匹配3次或更多次。
   ?等同于{0,1}，*等同于{0，}，+等同于{1，}

