第7章 正则表达式(Regular Expressions)
   JavaScript的许多特性都借鉴自其它语言。语法借鉴自Java，函数借鉴自Scheme，原型借鉴自Self，而JavaScript的正则表达式则借鉴自Perl。
   JavaScript中，正则表达式必须写在一行中，正则表达式中的空白是至关重要的。

var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

   ^ 表示这个字符串的开始，它是一个标记，用来防止exec跳过不像URL(non-URL-like)的前缀：

   (?:([A-Za-z]+):)?
这个因子匹配一个协议名，但仅当他之后跟随一个:的时候才匹配。(?:...)表示一个非捕获型分组。后缀?表示这个分组是可选的。（...）表示一个捕获型分组，一个捕获型分组都将被指定一个编号。第一个捕获型分组的编号是1，所以改风阻所匹配的文本拷贝将出现在result[2]中。   [...]表示一个字符类，这个字符类A-Za-a包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。后缀+表示这个字符类将被匹配1次或多次。这个组后面跟着字符：，它将按字面进行匹配:
   (\/{0,3})
下一个因子是捕获型分组2，\/表示一个应该被匹配的/（斜杠）。它用\（反斜杠）来进行转义，这样它就不会被错误的解释为这个正则表达式的结束符。后缀{0,3}表示/将被匹配0次，或者1到3次之间：
   ([0-9.\-A-Za-z]+)
下一个因子是捕获型分组3，它将匹配一个主机名，有1个或多个数字而组成的序列。\d表示一个数字字符。1个或多个数字组成的数字串将被捕获型分组4捕获：
   (?::(\d+))?
下一个可选的因子将匹配端口号，它是由一个前置：加上1个或多个数字而组成的序列。\d表示一个数字字符。1个或多个数字组成的数字串将被捕获型分组4捕获：
   (?:\/([^?#]*))?
我们有另一个可选的分组，该分组以一个/开始。之后的字符类{^?#}以一个^开始，它表示这个类包含除？和#之外的所有字符。*表示这个字符类将被匹配0次或多次。
   (?:\?([^?#]*))?
一个以一个?开始的可选分组，它包含捕获型分组6，这个分组包含0个或多个非#字符：
   (?:#(.*))?
最后一个可选分组也是以#开始的，.将匹配除行结束符以外的所有字符：
   $
$表示这个字符串的结束，它让我们确信这个URL的尾部没有其他更多的内容。

@一个匹配数字的正则表达式

var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
var test = function(num) {
    document.writeln(parse_number.test(num));
};
test('1');     //false
>>> test('numbers');   //false
>>> test('98.6');    //true
>>> test('132.21.86.100');  /false
>>> test('123.45e-67');   //true

  /^  $/i
用^和$来框定这个正则表达式，它将导致文本中的所有字符都要针对这个正则表达式进行匹如果我们省略了这些表示，那么只要一个字符串包含一个数字，这个正则表达式就会告诉我们。但有了这些标识，只有当一个字符串的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^，它将匹配一个数字开头的字符串，如果我们仅包含$，则匹配一个数字结尾的字符串。
i标识规定当匹配字母是可以忽略大小写，在我们模式中唯一可能出现的字母是e。我们希望e也能匹配E。我们可以将e因子写成[Ee]或(?:E|e)，但不必这么麻烦，因为我们使用了标识符:i:
   -?
减号后面的？后缀表示这个减号是可选的：
   /d+
\d的含义和[0-9]一样。它匹配一个数字。后缀+规定它可以匹配1个或多个数字：
   (?:\.\d*)
（？:....）？表示一个可选的非捕获型分组。通常用非捕获型分组来替代少量不优美的捕获型分组是很好的方法，因为捕获会有性能上的损失。这个分组将匹配后面跟随0个或多个数字的小数点：
   (?:e[+\-]?\d+)?
这是另外一个可选的非捕获型分组，它将匹配一个e(或E)、一个可选的正负号及一个或多个数字。